<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Zoomable PNG Viewer</title>
  <style>
    :root{
      --bg:#0b1220;        /* page background */
      --panel:#121a2b;     /* toolbar & dropzone */
      --ink:#e8efff;       /* primary text */
      --muted:#9fb0cf;     /* secondary text */
      --accent:#6ea8ff;    /* buttons / focus */
      --ring: rgba(110,168,255,.35);
      --shadow: 0 10px 30px rgba(2,8,23,.45);
      --radius: 14px;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: radial-gradient(1200px 800px at 20% -10%, #101a33 0%, #0b1220 55%, #080e19 100%);
      color: var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow: hidden; /* keep the page tidy during pan */
    }

    /* Toolbar */
    .toolbar {
      position: fixed; inset: 16px 16px auto 16px; display: flex; gap: 10px; align-items: center;
      background: color-mix(in oklab, var(--panel) 88%, black 12%);
      border: 1px solid color-mix(in oklab, var(--panel) 70%, white 5%);
      box-shadow: var(--shadow); border-radius: var(--radius); padding: 10px 12px; z-index: 5;
      backdrop-filter: blur(6px);
    }
    .toolbar .group { display:flex; gap:8px; align-items:center; }
    .btn {
      display:inline-flex; align-items:center; justify-content:center; gap:8px;
      height:36px; min-width:36px; padding:0 12px; border-radius: 10px;
      background: #111a2a; border: 1px solid #1e2b46; color: var(--ink); cursor:pointer;
      user-select:none; -webkit-user-select:none; touch-action: manipulation;
    }
    .btn:hover { border-color:#2b3b60; }
    .btn:active { transform: translateY(1px); }
    .btn svg { width:18px; height:18px; }

    /* File input visually hidden, label styled as button */
    input[type=file]{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }
    label[for=imageInput].btn { gap:10px; }

    .sep { width:1px; height:28px; background: #263453; margin: 0 2px; }

    .hint { color: var(--muted); font-size: 12px; padding-left:6px; }

    /* Viewport */
    .viewport {
      position: absolute; inset: 0; overflow: hidden; touch-action: none; /* we handle gestures */
      outline: none; /* focus ring set via JS */
    }
    .viewport:focus { box-shadow: inset 0 0 0 2px var(--ring); }

    /* Dropzone overlay (only visible when empty or dragging) */
    .dropzone {
      position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none; color: var(--muted);
    }
    .dropcard {
      pointer-events: auto; text-align: center; padding: 22px 26px; border-radius: var(--radius);
      border:1px dashed #2a3b61; background: color-mix(in oklab, var(--panel) 75%, black 25%);
      box-shadow: var(--shadow);
    }
    .dropcard strong{ color: var(--ink); }
    .drop-active .dropcard { outline: 2px solid var(--accent); box-shadow: 0 0 0 6px var(--ring); }

    /* Layer with transform */
    .layer { position: absolute; inset: 0; will-change: transform; }
    .layer img { position: absolute; top:0; left:0; transform-origin: 0 0; image-rendering: auto; max-width: none; }

    /* Bottom-left status pill */
    .status {
      position: fixed; left: 16px; bottom: 16px; font-size: 12px; color: var(--muted);
      background: color-mix(in oklab, var(--panel) 88%, black 12%);
      border: 1px solid #263453; border-radius: 999px; padding: 8px 12px; box-shadow: var(--shadow);
      user-select: none;
    }
    .status code{ color: var(--ink); }

    a.link { color: var(--accent); text-decoration: none; }
    a.link:hover{ text-decoration: underline; }
  </style>
</head>
<body>
  <div class="toolbar" role="toolbar" aria-label="Image controls">
    <div class="group">
      <label class="btn" for="imageInput" title="Open image (PNG/JPG)">
        <svg viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M12 16V4m0 0l-4 4m4-4l4 4M4 20h16" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
        <span>Open</span>
      </label>
      <input id="imageInput" type="file" accept="image/png,image/jpeg,image/webp" />
    </div>
    <div class="sep" aria-hidden="true"></div>
    <div class="group">
      <button class="btn" id="zoomOut" title="Zoom Out (−)">
        <svg viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M5 12h14" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/></svg>
      </button>
      <button class="btn" id="zoomIn" title="Zoom In (= / +)">
        <svg viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/></svg>
      </button>
      <button class="btn" id="reset" title="Reset (0)">
        <svg viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M4 4v6h6M20 20v-6h-6M20 10A8 8 0 104 14" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
        <span>Fit</span>
      </button>
      <span class="hint">Scroll to zoom • drag to pan • double‑click/tap to toggle zoom • pinch on touch</span>
    </div>
  </div>

  <div id="viewport" class="viewport" tabindex="0" aria-label="Zoomable image viewport">
    <div class="layer"><img id="img" alt="" /></div>
    <div class="dropzone" id="dropzone">
      <div class="dropcard">
        <div style="font-size:18px; margin-bottom:6px;">Drop an image here</div>
        <div>or use <strong>Open</strong> above. PNG/JPG/WebP supported.</div>
      </div>
    </div>
  </div>

  <div class="status" id="status">Scale: <code>—</code> &nbsp;•&nbsp; Pos: <code>—, —</code></div>

  <script>
  (function(){
    const viewport = document.getElementById('viewport');
    const layer = document.querySelector('.layer');
    const img = document.getElementById('img');
    const dropzone = document.getElementById('dropzone');
    const status = document.getElementById('status');

    const input = document.getElementById('imageInput');
    const btnIn = document.getElementById('zoomIn');
    const btnOut = document.getElementById('zoomOut');
    const btnFit = document.getElementById('reset');

    let state = {
      ready: false,
      imgW: 0, imgH: 0,               // natural image size
      scale: 1,                        // current scale
      minScale: 1, maxScale: 20,       // clamped
      tx: 0, ty: 0,                    // translation (CSS px)
    };

    function setStatus(){
      status.innerHTML = `Scale: <code>${state.scale.toFixed(2)}×</code> &nbsp;•&nbsp; Pos: <code>${Math.round(state.tx)}, ${Math.round(state.ty)}</code>`;
    }

    function applyTransform(){
      img.style.transform = `translate(${state.tx}px, ${state.ty}px) scale(${state.scale})`;
      setStatus();
    }

    function fitToScreen(){
      const vw = viewport.clientWidth, vh = viewport.clientHeight;
      const sx = vw / state.imgW, sy = vh / state.imgH;
      state.scale = Math.min(sx, sy);
      state.minScale = state.scale * 0.5; // allow slight zoom-out beyond fit
      state.maxScale = Math.max(20, state.scale * 10);
      const scaledW = state.imgW * state.scale;
      const scaledH = state.imgH * state.scale;
      state.tx = (vw - scaledW) / 2;
      state.ty = (vh - scaledH) / 2;
      applyTransform();
    }

    function clampTranslation(){
      const vw = viewport.clientWidth, vh = viewport.clientHeight;
      const sw = state.imgW * state.scale, sh = state.imgH * state.scale;

      if (sw <= vw) {
        state.tx = (vw - sw) / 2; // center when image narrower than viewport
      } else {
        const minX = vw - sw, maxX = 0;
        state.tx = Math.min(maxX, Math.max(minX, state.tx));
      }
      if (sh <= vh) {
        state.ty = (vh - sh) / 2;
      } else {
        const minY = vh - sh, maxY = 0;
        state.ty = Math.min(maxY, Math.max(minY, state.ty));
      }
    }

    function zoomAt(cx, cy, factor){
      const newScale = Math.min(state.maxScale, Math.max(state.minScale, state.scale * factor));
      factor = newScale / state.scale; // effective factor after clamping
      // Keep the point under the cursor fixed during zoom
      state.tx = cx - (cx - state.tx) * factor;
      state.ty = cy - (cy - state.ty) * factor;
      state.scale = newScale;
      clampTranslation();
      applyTransform();
    }

    function loadFile(file){
      if(!file) return;
      const url = URL.createObjectURL(file);
      img.onload = () => {
        state.imgW = img.naturalWidth;
        state.imgH = img.naturalHeight;
        state.ready = true;
        dropzone.style.display = 'none';
        fitToScreen();
        URL.revokeObjectURL(url);
        viewport.focus({preventScroll:true});
      };
      img.src = url;
    }

    // --- File input & drag-drop ---
    input.addEventListener('change', (e)=> loadFile(e.target.files?.[0]));

    ['dragenter','dragover'].forEach(evt => {
      viewport.addEventListener(evt, e => {
        e.preventDefault(); e.stopPropagation();
        document.body.classList.add('drop-active');
      });
    });
    ;['dragleave','drop'].forEach(evt => {
      viewport.addEventListener(evt, e => {
        e.preventDefault(); e.stopPropagation();
        document.body.classList.remove('drop-active');
      });
    });
    viewport.addEventListener('drop', e => {
      const file = e.dataTransfer?.files?.[0];
      loadFile(file);
    });

    // --- Wheel zoom (mouse/trackpad) ---
    viewport.addEventListener('wheel', e => {
      if(!state.ready) return;
      e.preventDefault();
      const { clientX, clientY } = e;
      // normalize delta for smooth scaling (trackpads emit small deltas)
      const delta = -e.deltaY; // up = zoom in
      const zoomFactor = Math.exp(delta * 0.0015);
      zoomAt(clientX, clientY, zoomFactor);
    }, { passive:false });

    // --- Buttons & keyboard ---
    btnIn.addEventListener('click', ()=>{
      const rect = viewport.getBoundingClientRect();
      zoomAt(rect.width/2, rect.height/2, 1.2);
    });
    btnOut.addEventListener('click', ()=>{
      const rect = viewport.getBoundingClientRect();
      zoomAt(rect.width/2, rect.height/2, 1/1.2);
    });
    btnFit.addEventListener('click', ()=> state.ready && fitToScreen());

    window.addEventListener('resize', ()=> state.ready && (clampTranslation(), applyTransform()));

    window.addEventListener('keydown', (e)=>{
      if(!state.ready) return;
      if(e.key === '+' || e.key === '=') { btnIn.click(); }
      else if(e.key === '-') { btnOut.click(); }
      else if(e.key === '0') { btnFit.click(); }
      else if(e.key === ' ') { e.preventDefault(); viewport.focus({preventScroll:true}); }
    });

    // --- Double-click / Double-tap toggle ---
    viewport.addEventListener('dblclick', e => {
      if(!state.ready) return;
      const targetScale = state.scale < state.minScale * 1.2 ? state.minScale * 2 : (state.scale < state.scale*1 ? state.scale : state.minScale);
      // Simple toggle: if near fit -> zoom in, else fit
      const rect = viewport.getBoundingClientRect();
      const factor = (state.scale <= state.minScale * 1.25) ? 2 : (state.minScale / state.scale);
      zoomAt(e.clientX, e.clientY, factor);
    });

    // Touch double-tap detection
    let lastTapTime = 0, lastTapPos = null;

    function isDoubleTap(x,y){
      const now = Date.now();
      const okTime = now - lastTapTime < 300;
      const okDist = lastTapPos ? Math.hypot(x-lastTapPos.x, y-lastTapPos.y) < 40 : false;
      lastTapTime = now; lastTapPos = {x,y};
      return okTime && okDist;
    }

    // --- Unified Pointer events for pan & pinch ---
    const active = new Map(); // id -> {x,y}
    let dragging = false;     // one-finger/mouse pan
    let last = {x:0,y:0};

    let pinching = false;
    let prevDist = 0;         // previous distance between two pointers
    let prevCenter = {x:0,y:0};

    function getCenter(){
      const pts = Array.from(active.values());
      const cx = (pts[0].x + pts[1].x)/2;
      const cy = (pts[0].y + pts[1].y)/2;
      return {x:cx, y:cy};
    }
    function getDistance(){
      const pts = Array.from(active.values());
      return Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
    }

    viewport.addEventListener('pointerdown', e => {
      if(!state.ready) return;
      viewport.setPointerCapture(e.pointerId);
      active.set(e.pointerId, {x:e.clientX, y:e.clientY});

      if(active.size === 1){
        dragging = true; last.x = e.clientX; last.y = e.clientY;
        // double-tap (touch only)
        if(e.pointerType === 'touch' && isDoubleTap(e.clientX, e.clientY)){
          const factor = (state.scale <= state.minScale * 1.25) ? 2 : (state.minScale / state.scale);
          zoomAt(e.clientX, e.clientY, factor);
          // After double-tap, stop this event from initiating a drag
          dragging = false; active.clear();
          return;
        }
      } else if(active.size === 2){
        pinching = true; dragging = false; // switch to pinch
        prevCenter = getCenter();
        prevDist = getDistance();
      }
    });

    viewport.addEventListener('pointermove', e => {
      if(!state.ready) return;
      if(!active.has(e.pointerId)) return;
      active.set(e.pointerId, {x:e.clientX, y:e.clientY});

      if(pinching && active.size === 2){
        const center = getCenter();
        const dist = getDistance();
        if(prevDist > 0){
          const factor = dist / prevDist;
          // Zoom around current center, then add pan by center movement
          const newScale = Math.min(state.maxScale, Math.max(state.minScale, state.scale * factor));
          const eff = newScale / state.scale;
          state.tx = center.x - (center.x - state.tx) * eff + (center.x - prevCenter.x);
          state.ty = center.y - (center.y - state.ty) * eff + (center.y - prevCenter.y);
          state.scale = newScale;
          clampTranslation();
          applyTransform();
        }
        prevCenter = center; prevDist = dist;
      } else if(dragging && active.size === 1){
        const dx = e.clientX - last.x; const dy = e.clientY - last.y;
        state.tx += dx; state.ty += dy;
        last.x = e.clientX; last.y = e.clientY;
        clampTranslation();
        applyTransform();
      }
    });

    function endPointer(e){
      if(active.has(e.pointerId)) active.delete(e.pointerId);
      if(active.size < 2){ pinching = false; prevDist = 0; }
      if(active.size === 0){ dragging = false; }
    }
    viewport.addEventListener('pointerup', endPointer);
    viewport.addEventListener('pointercancel', endPointer);
    viewport.addEventListener('pointerleave', endPointer);

    // Kick off with a demo gradient if no image is provided (optional)
    // Comment this block if you prefer a blank start.
    // Kick off with background.png if no image is provided
    (function loadDefault(){
      img.onload = () => {
        state.imgW = img.naturalWidth;
        state.imgH = img.naturalHeight;
        state.ready = true;
        dropzone.style.display = 'none';
        fitToScreen();
      };
      img.src = "background.png";  // <-- use background.png in same folder as index.html
    })();

  })();
  </script>
</body>
</html>
